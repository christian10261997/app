// Hugging Face API service for AI recipe generation
import { AIRecipeRequest, AIRecipeResponse, HuggingFaceRequest, HuggingFaceResponse } from "../types/api";
import { APIClient } from "./apiClient";

// Environment configuration (these should be set in your environment)
const HUGGINGFACE_API_KEY = process.env.EXPO_PUBLIC_HUGGINGFACE_API_KEY || "";
const HUGGINGFACE_MODELS = ["google/flan-t5-small", "microsoft/DialoGPT-small", "EleutherAI/gpt-neo-125M", "facebook/opt-125m"]; // Fallback models in order of preference
const HUGGINGFACE_MODEL = HUGGINGFACE_MODELS[0]; // Primary model

export class HuggingFaceService {
  private client: APIClient;
  private isEnabled: boolean;

  constructor() {
    this.isEnabled = !!HUGGINGFACE_API_KEY;

    this.client = new APIClient({
      name: "HuggingFace",
      baseUrl: "https://api-inference.huggingface.co/models/",
      apiKey: HUGGINGFACE_API_KEY,
      timeout: 30000, // 30 seconds for AI processing
      retryAttempts: 2,
      enabled: this.isEnabled,
    });
  }

  /**
   * Generate a recipe using Hugging Face AI models
   */
  async generateRecipe(request: AIRecipeRequest): Promise<AIRecipeResponse> {
    if (!this.isEnabled) {
      return {
        success: false,
        error: "Hugging Face API key not configured",
        fallbackUsed: true,
      };
    }

    try {
      const prompt = this.buildRecipePrompt(request);
      const startTime = Date.now();

      const hfRequest: HuggingFaceRequest = {
        inputs: prompt,
        parameters: {
          max_new_tokens: 800,
          temperature: 0.7,
          top_p: 0.9,
          do_sample: true,
          return_full_text: false,
        },
        options: {
          wait_for_model: true,
          use_cache: false,
        },
      };

      const response = await this.tryModelsWithFallback(hfRequest);

      if (!response.success || !response.data) {
        // If AI fails, use local fallback recipe generation
        console.log("🔄 AI failed, using local fallback recipe generation");
        const fallbackRecipe = this.generateFallbackRecipe(request);
        return {
          success: true,
          recipe: fallbackRecipe,
          fallbackUsed: true,
          apiMetadata: {
            model: "local-fallback",
            processingTime: Date.now() - startTime,
            tokensUsed: 0,
          },
        };
      }

      const processingTime = Date.now() - startTime;
      const aiResponse = response.data[0];

      if (!aiResponse?.generated_text) {
        return {
          success: false,
          error: "No recipe generated by AI",
          fallbackUsed: true,
        };
      }

      // Parse the AI response into a structured recipe
      const parsedRecipe = this.parseAIResponse(aiResponse.generated_text, request);

      if (!parsedRecipe) {
        console.log("🔄 AI parsing failed, using local fallback recipe generation");
        const fallbackRecipe = this.generateFallbackRecipe(request);
        return {
          success: true,
          recipe: fallbackRecipe,
          fallbackUsed: true,
          apiMetadata: {
            model: "local-fallback",
            processingTime,
            tokensUsed: 0,
          },
        };
      }

      return {
        success: true,
        recipe: parsedRecipe,
        apiMetadata: {
          model: HUGGINGFACE_MODEL,
          processingTime,
          tokensUsed: aiResponse.generated_text.length,
        },
      };
    } catch (error: any) {
      console.error("Hugging Face API error:", error);
      console.log("🔄 AI service error, using local fallback recipe generation");
      const fallbackRecipe = this.generateFallbackRecipe(request);
      return {
        success: true,
        recipe: fallbackRecipe,
        fallbackUsed: true,
        apiMetadata: {
          model: "local-fallback",
          processingTime: 0,
          tokensUsed: 0,
        },
      };
    }
  }

  /**
   * Try multiple models with fallback in case primary model fails
   */
  private async tryModelsWithFallback(hfRequest: HuggingFaceRequest): Promise<{ success: boolean; data?: HuggingFaceResponse[]; error?: string }> {
    for (let i = 0; i < HUGGINGFACE_MODELS.length; i++) {
      const model = HUGGINGFACE_MODELS[i];
      console.log(`🔄 Trying model: ${model} (${i + 1}/${HUGGINGFACE_MODELS.length})`);

      try {
        const response = await this.client.makeRequest<HuggingFaceResponse[]>(model, {
          method: "POST",
          body: hfRequest,
        });

        if (response.success && response.data) {
          console.log(`✅ Model ${model} worked successfully`);
          return response;
        } else {
          console.log(`❌ Model ${model} failed: ${response.error}`);
          // Continue to next model
        }
      } catch (error: any) {
        console.log(`❌ Model ${model} error: ${error.message}`);
        // Continue to next model
      }
    }

    // All models failed
    return {
      success: false,
      error: "All available models failed to respond",
    };
  }

  /**
   * Build an optimized prompt for original recipe generation
   */
  private buildRecipePrompt(request: AIRecipeRequest): string {
    const { ingredients, preferences, context } = request;
    const filipinoBias = context?.useFilipinoBias !== false; // Default to true

    let prompt = "Create a recipe with the following format:\n\n";
    prompt += "RECIPE NAME: [Recipe name - can be traditional Filipino dish or creative new name]\n";
    prompt += "DESCRIPTION: [Brief description of the dish]\n";
    prompt += "PREP TIME: [minutes]\n";
    prompt += "COOK TIME: [minutes]\n";
    prompt += "SERVINGS: [number]\n";
    prompt += "DIFFICULTY: [Easy/Medium/Hard]\n";
    prompt += "CUISINE: [cuisine type]\n";
    prompt += "CATEGORY: [Breakfast/Main Course/etc.]\n";
    prompt += "INGREDIENTS:\n";
    prompt += "- [ingredient with quantity]\n";
    prompt += "INSTRUCTIONS:\n";
    prompt += "1. [step by step instructions]\n\n";

    prompt += `Create a recipe using these ingredients as the main components: ${ingredients.join(", ")}.\n`;
    prompt +=
      "You can either: (1) Create a traditional Filipino recipe that uses these ingredients (like adobo, sinigang, tinola, etc.), or (2) Invent a completely new and original dish with a creative name. ";
    prompt += "If creating a traditional dish, ensure it follows authentic Filipino cooking methods and seasonings. ";
    prompt += "If inventing a new dish, give it a creative name that describes the ingredients and cooking method.\n";

    if (filipinoBias) {
      prompt += "Use Filipino cooking techniques and flavor profiles when possible. ";
      prompt += "You may add common Filipino seasonings like soy sauce, vinegar, garlic, onions, ginger to complement the main ingredients. ";
    }

    if (preferences?.cuisine && preferences.cuisine !== "Filipino") {
      prompt += `Cuisine style: ${preferences.cuisine}. `;
      prompt += "Adapt the cooking techniques and seasonings to match this cuisine style. ";
    }

    if (preferences?.category) {
      prompt += `Category: ${preferences.category}. `;
    }

    if (preferences?.difficulty) {
      prompt += `Difficulty level: ${preferences.difficulty}. `;
    }

    if (preferences?.maxPrepTime) {
      prompt += `Maximum prep time: ${preferences.maxPrepTime} minutes. `;
    }

    if (preferences?.servings) {
      prompt += `Serves: ${preferences.servings} people. `;
    }

    if (preferences?.dietary?.length) {
      prompt += `Dietary requirements: ${preferences.dietary.join(", ")}. `;
    }

    prompt += "\nEnsure the recipe is practical, delicious, and the name clearly describes what the dish is.";

    return prompt;
  }

  /**
   * Parse AI response text into structured recipe data
   */
  private parseAIResponse(aiText: string, request: AIRecipeRequest): AIRecipeResponse["recipe"] | null {
    try {
      const lines = aiText
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);
      const recipe: any = {
        tags: [],
        confidence: 0.8, // Default confidence for AI recipes
        source: "ai" as const,
      };

      let currentSection = "";
      let ingredientsList: string[] = [];
      let instructionsList: string[] = [];

      for (const line of lines) {
        const upperLine = line.toUpperCase();

        // Parse structured fields
        if (upperLine.startsWith("RECIPE NAME:")) {
          recipe.name = line.substring(12).trim();
        } else if (upperLine.startsWith("DESCRIPTION:")) {
          recipe.description = line.substring(12).trim();
        } else if (upperLine.startsWith("PREP TIME:")) {
          const match = line.match(/(\d+)/);
          recipe.prepTime = match ? parseInt(match[1]) : 30;
        } else if (upperLine.startsWith("COOK TIME:")) {
          const match = line.match(/(\d+)/);
          recipe.cookTime = match ? parseInt(match[1]) : 30;
        } else if (upperLine.startsWith("SERVINGS:")) {
          const match = line.match(/(\d+)/);
          recipe.servings = match ? parseInt(match[1]) : 4;
        } else if (upperLine.startsWith("DIFFICULTY:")) {
          const difficulty = line.substring(11).trim();
          recipe.difficulty = ["Easy", "Medium", "Hard"].includes(difficulty) ? difficulty : "Medium";
        } else if (upperLine.startsWith("CUISINE:")) {
          recipe.cuisine = line.substring(8).trim();
        } else if (upperLine.startsWith("CATEGORY:")) {
          recipe.category = line.substring(9).trim();
        } else if (upperLine === "INGREDIENTS:") {
          currentSection = "ingredients";
        } else if (upperLine === "INSTRUCTIONS:") {
          currentSection = "instructions";
        } else if (line.startsWith("-") && currentSection === "ingredients") {
          ingredientsList.push(line.substring(1).trim());
        } else if (/^\d+\./.test(line) && currentSection === "instructions") {
          instructionsList.push(line.replace(/^\d+\.\s*/, "").trim());
        }
      }

      // Set defaults and validate
      recipe.name = recipe.name || this.generateDefaultName(request.ingredients);
      recipe.description = recipe.description || `A delicious recipe featuring ${request.ingredients.join(", ")}.`;
      recipe.prepTime = recipe.prepTime || 20;
      recipe.cookTime = recipe.cookTime || 30;
      recipe.servings = recipe.servings || 4;
      recipe.difficulty = recipe.difficulty || "Medium";
      recipe.cuisine = recipe.cuisine || (request.context?.useFilipinoBias !== false ? "Filipino" : "International");
      recipe.category = recipe.category || request.preferences?.category || "Main Course";
      recipe.ingredients = ingredientsList.length > 0 ? ingredientsList : this.generateDefaultIngredients(request.ingredients);
      recipe.instructions = instructionsList.length > 0 ? instructionsList : this.generateDefaultInstructions(request.ingredients);

      // Generate tags
      recipe.tags = this.generateTags(recipe, request);

      // Validate required fields
      if (!recipe.name || !recipe.ingredients.length || !recipe.instructions.length) {
        return null;
      }

      return recipe;
    } catch (error) {
      console.error("Error parsing AI response:", error);
      return null;
    }
  }

  private generateDefaultName(ingredients: string[]): string {
    const primary = ingredients[0] || "Mixed";
    return `${primary.charAt(0).toUpperCase() + primary.slice(1)} Delight`;
  }

  private generateDefaultIngredients(userIngredients: string[]): string[] {
    return userIngredients.map((ing) => `1 cup ${ing}`);
  }

  private generateDefaultInstructions(ingredients: string[]): string[] {
    return [
      `Prepare all ingredients: ${ingredients.join(", ")}.`,
      "Heat oil in a large pan over medium heat.",
      "Add ingredients according to cooking time requirements.",
      "Cook until tender and well combined.",
      "Season with salt and pepper to taste.",
      "Serve hot and enjoy!",
    ];
  }

  private generateTags(recipe: any, request: AIRecipeRequest): string[] {
    const tags = ["ai-generated"];

    if (request.context?.useFilipinoBias !== false) {
      tags.push("filipino-inspired");
    }

    if (recipe.difficulty === "Easy") {
      tags.push("quick", "beginner-friendly");
    }

    if (recipe.prepTime <= 15) {
      tags.push("quick-prep");
    }

    if (recipe.cookTime <= 30) {
      tags.push("quick-cook");
    }

    return tags;
  }

  /**
   * Generate a fallback recipe when AI services are unavailable
   */
  private generateFallbackRecipe(request: AIRecipeRequest): AIRecipeResponse["recipe"] {
    const { ingredients, preferences } = request;

    // Create a simple but practical recipe based on ingredients
    const recipeName = this.generateFallbackRecipeName(ingredients, preferences?.cuisine);
    const isFilipino = !preferences?.cuisine || preferences?.cuisine === "Filipino";

    return {
      name: recipeName,
      description: `A delicious ${isFilipino ? "Filipino-style" : ""} dish featuring ${ingredients.slice(0, 3).join(", ")}${ingredients.length > 3 ? " and more" : ""}.`,
      prepTime: preferences?.maxPrepTime || 20,
      cookTime: 25,
      servings: preferences?.servings || 4,
      difficulty: (preferences?.difficulty as "Easy" | "Medium" | "Hard") || "Medium",
      cuisine: preferences?.cuisine || "Filipino",
      category: preferences?.category || "Main Course",
      ingredients: this.generateFallbackIngredients(ingredients, isFilipino),
      instructions: this.generateFallbackInstructions(ingredients, isFilipino),
      tags: this.generateFallbackTags(preferences, isFilipino),
      confidence: 0.6, // Lower confidence for fallback
      source: "local" as const,
    };
  }

  private generateFallbackRecipeName(ingredients: string[], cuisine?: string): string {
    const primary = ingredients[0]?.toLowerCase() || "mixed";
    const isFilipino = !cuisine || cuisine === "Filipino";

    if (isFilipino) {
      // Generate Filipino-style names
      if (ingredients.some((ing) => ing.toLowerCase().includes("chicken"))) {
        return "Chicken Adobo Delight";
      }
      if (ingredients.some((ing) => ing.toLowerCase().includes("pork"))) {
        return "Pork Guisado Supreme";
      }
      if (ingredients.some((ing) => ing.toLowerCase().includes("fish"))) {
        return "Fish Sinigang Fusion";
      }
      if (ingredients.some((ing) => ing.toLowerCase().includes("egg"))) {
        return "Torta Style Scramble";
      }
      return `${primary.charAt(0).toUpperCase() + primary.slice(1)} Kapampangan Style`;
    }

    return `${primary.charAt(0).toUpperCase() + primary.slice(1)} Fusion Delight`;
  }

  private generateFallbackIngredients(userIngredients: string[], isFilipino: boolean): string[] {
    const baseIngredients = userIngredients.map((ing) => `1 cup ${ing}`);

    if (isFilipino) {
      return [...baseIngredients, "2 cloves garlic, minced", "1 medium onion, sliced", "2 tbsp soy sauce", "1 tbsp vinegar", "1 tsp black pepper", "2 tbsp cooking oil", "Salt to taste"];
    }

    return [...baseIngredients, "2 cloves garlic, minced", "1 medium onion, diced", "2 tbsp olive oil", "Salt and pepper to taste"];
  }

  private generateFallbackInstructions(ingredients: string[], isFilipino: boolean): string[] {
    if (isFilipino) {
      return [
        "Heat oil in a large pan over medium heat.",
        "Sauté garlic and onions until fragrant and golden.",
        `Add the main ingredients: ${ingredients.slice(0, 2).join(" and ")}.`,
        "Pour in soy sauce and vinegar. Let it simmer without stirring for 3 minutes.",
        "Add black pepper and mix gently.",
        "Cover and simmer for 15-20 minutes until tender.",
        "Season with salt to taste.",
        "Serve hot with steamed rice. Enjoy your Filipino feast!",
      ];
    }

    return [
      "Heat olive oil in a large skillet over medium heat.",
      "Add garlic and onions, cook until softened.",
      `Add ${ingredients.join(", ")} and cook until properly heated through.`,
      "Season with salt and pepper to taste.",
      "Cook for 10-15 minutes, stirring occasionally.",
      "Serve hot and enjoy!",
    ];
  }

  private generateFallbackTags(preferences: any, isFilipino: boolean): string[] {
    const tags = ["local-fallback", "quick-recipe"];

    if (isFilipino) {
      tags.push("filipino", "comfort-food");
    }

    if (preferences?.difficulty === "Easy") {
      tags.push("beginner-friendly");
    }

    return tags;
  }

  /**
   * Check if the service is properly configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Validate ingredients using AI to determine if they are edible and safe
   */
  async validateIngredients(prompt: string): Promise<{ success: boolean; result?: any; error?: string }> {
    if (!this.isEnabled) {
      return {
        success: false,
        error: "Hugging Face API key not configured",
      };
    }

    try {
      const hfRequest: HuggingFaceRequest = {
        inputs: prompt,
        parameters: {
          max_new_tokens: 200,
          temperature: 0.1, // Low temperature for consistent validation
          top_p: 0.9,
          do_sample: true,
          return_full_text: false,
        },
        options: {
          wait_for_model: true,
          use_cache: false,
        },
      };

      const response = await this.tryModelsWithFallback(hfRequest);

      if (!response.success || !response.data) {
        return {
          success: false,
          error: response.error || "Failed to get AI validation response",
        };
      }

      const aiResponse = response.data[0];
      if (!aiResponse?.generated_text) {
        return {
          success: false,
          error: "No validation response from AI",
        };
      }

      // Parse the AI validation response
      const validationResult = this.parseValidationResponse(aiResponse.generated_text);

      return {
        success: true,
        result: validationResult,
      };
    } catch (error: any) {
      console.error("Ingredient validation error:", error);
      return {
        success: false,
        error: error.message || "AI validation service unavailable",
      };
    }
  }

  /**
   * Parse AI validation response into structured data
   */
  private parseValidationResponse(aiText: string): { allEdible: boolean; inedibleIngredients: string[]; reason?: string } {
    try {
      const lines = aiText
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);

      let result = "SAFE";
      let inedibleIngredients: string[] = [];
      let reason = "";

      for (const line of lines) {
        const upperLine = line.toUpperCase();

        if (upperLine.startsWith("RESULT:")) {
          result = line.substring(7).trim().toUpperCase();
        } else if (upperLine.startsWith("INEDIBLE_INGREDIENTS:")) {
          const ingredientsText = line.substring(21).trim();
          inedibleIngredients = ingredientsText
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean);
        } else if (upperLine.startsWith("REASON:")) {
          reason = line.substring(7).trim();
        }
      }

      const allEdible = result === "SAFE" && inedibleIngredients.length === 0;

      return {
        allEdible,
        inedibleIngredients,
        reason,
      };
    } catch (error) {
      console.error("Error parsing validation response:", error);
      // Fail-safe: assume ingredients are edible if parsing fails
      return {
        allEdible: true,
        inedibleIngredients: [],
        reason: "Could not parse validation response",
      };
    }
  }

  /**
   * Test the API connection
   */
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    if (!this.isEnabled) {
      return { success: false, error: "API key not configured" };
    }

    try {
      const response = await this.client.makeRequest(HUGGINGFACE_MODEL, {
        method: "POST",
        body: {
          inputs: "Test connection",
          parameters: { max_new_tokens: 10 },
        },
      });

      return { success: response.success, error: response.error };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }
}

// Singleton instance
export const huggingFaceService = new HuggingFaceService();
