// Hugging Face API service for AI recipe generation
import { AIRecipeRequest, AIRecipeResponse, HuggingFaceRequest, HuggingFaceResponse } from "../types/api";
import { APIClient } from "./apiClient";

// Environment configuration (these should be set in your environment)
const HUGGINGFACE_API_KEY = process.env.EXPO_PUBLIC_HUGGINGFACE_API_KEY || "";
const HUGGINGFACE_MODEL = "microsoft/DialoGPT-medium"; // Can be changed to other models

export class HuggingFaceService {
  private client: APIClient;
  private isEnabled: boolean;

  constructor() {
    this.isEnabled = !!HUGGINGFACE_API_KEY;

    this.client = new APIClient({
      name: "HuggingFace",
      baseUrl: "https://api-inference.huggingface.co/models/",
      apiKey: HUGGINGFACE_API_KEY,
      timeout: 30000, // 30 seconds for AI processing
      retryAttempts: 2,
      enabled: this.isEnabled,
    });
  }

  /**
   * Generate a recipe using Hugging Face AI models
   */
  async generateRecipe(request: AIRecipeRequest): Promise<AIRecipeResponse> {
    if (!this.isEnabled) {
      return {
        success: false,
        error: "Hugging Face API key not configured",
        fallbackUsed: true,
      };
    }

    try {
      const prompt = this.buildRecipePrompt(request);
      const startTime = Date.now();

      const hfRequest: HuggingFaceRequest = {
        inputs: prompt,
        parameters: {
          max_new_tokens: 800,
          temperature: 0.7,
          top_p: 0.9,
          do_sample: true,
          return_full_text: false,
        },
        options: {
          wait_for_model: true,
          use_cache: false,
        },
      };

      const response = await this.client.makeRequest<HuggingFaceResponse[]>(HUGGINGFACE_MODEL, {
        method: "POST",
        body: hfRequest,
      });

      if (!response.success || !response.data) {
        return {
          success: false,
          error: response.error || "Failed to get AI response",
          fallbackUsed: true,
        };
      }

      const processingTime = Date.now() - startTime;
      const aiResponse = response.data[0];

      if (!aiResponse?.generated_text) {
        return {
          success: false,
          error: "No recipe generated by AI",
          fallbackUsed: true,
        };
      }

      // Parse the AI response into a structured recipe
      const parsedRecipe = this.parseAIResponse(aiResponse.generated_text, request);

      if (!parsedRecipe) {
        return {
          success: false,
          error: "Failed to parse AI response into valid recipe",
          fallbackUsed: true,
        };
      }

      return {
        success: true,
        recipe: parsedRecipe,
        apiMetadata: {
          model: HUGGINGFACE_MODEL,
          processingTime,
          tokensUsed: aiResponse.generated_text.length,
        },
      };
    } catch (error: any) {
      console.error("Hugging Face API error:", error);
      return {
        success: false,
        error: error.message || "AI service unavailable",
        fallbackUsed: true,
      };
    }
  }

  /**
   * Build an optimized prompt for original recipe generation
   */
  private buildRecipePrompt(request: AIRecipeRequest): string {
    const { ingredients, preferences, context } = request;
    const filipinoBias = context?.useFilipinoBias !== false; // Default to true

    let prompt = "Create a recipe with the following format:\n\n";
    prompt += "RECIPE NAME: [Recipe name - can be traditional Filipino dish or creative new name]\n";
    prompt += "DESCRIPTION: [Brief description of the dish]\n";
    prompt += "PREP TIME: [minutes]\n";
    prompt += "COOK TIME: [minutes]\n";
    prompt += "SERVINGS: [number]\n";
    prompt += "DIFFICULTY: [Easy/Medium/Hard]\n";
    prompt += "CUISINE: [cuisine type]\n";
    prompt += "CATEGORY: [Breakfast/Main Course/etc.]\n";
    prompt += "INGREDIENTS:\n";
    prompt += "- [ingredient with quantity]\n";
    prompt += "INSTRUCTIONS:\n";
    prompt += "1. [step by step instructions]\n\n";

    prompt += `Create a recipe using these ingredients as the main components: ${ingredients.join(", ")}.\n`;
    prompt +=
      "You can either: (1) Create a traditional Filipino recipe that uses these ingredients (like adobo, sinigang, tinola, etc.), or (2) Invent a completely new and original dish with a creative name. ";
    prompt += "If creating a traditional dish, ensure it follows authentic Filipino cooking methods and seasonings. ";
    prompt += "If inventing a new dish, give it a creative name that describes the ingredients and cooking method.\n";

    if (filipinoBias) {
      prompt += "Use Filipino cooking techniques and flavor profiles when possible. ";
      prompt += "You may add common Filipino seasonings like soy sauce, vinegar, garlic, onions, ginger to complement the main ingredients. ";
    }

    if (preferences?.cuisine && preferences.cuisine !== "Filipino") {
      prompt += `Cuisine style: ${preferences.cuisine}. `;
      prompt += "Adapt the cooking techniques and seasonings to match this cuisine style. ";
    }

    if (preferences?.category) {
      prompt += `Category: ${preferences.category}. `;
    }

    if (preferences?.difficulty) {
      prompt += `Difficulty level: ${preferences.difficulty}. `;
    }

    if (preferences?.maxPrepTime) {
      prompt += `Maximum prep time: ${preferences.maxPrepTime} minutes. `;
    }

    if (preferences?.servings) {
      prompt += `Serves: ${preferences.servings} people. `;
    }

    if (preferences?.dietary?.length) {
      prompt += `Dietary requirements: ${preferences.dietary.join(", ")}. `;
    }

    prompt += "\nEnsure the recipe is practical, delicious, and the name clearly describes what the dish is.";

    return prompt;
  }

  /**
   * Parse AI response text into structured recipe data
   */
  private parseAIResponse(aiText: string, request: AIRecipeRequest): AIRecipeResponse["recipe"] | null {
    try {
      const lines = aiText
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);
      const recipe: any = {
        tags: [],
        confidence: 0.8, // Default confidence for AI recipes
        source: "ai" as const,
      };

      let currentSection = "";
      let ingredientsList: string[] = [];
      let instructionsList: string[] = [];

      for (const line of lines) {
        const upperLine = line.toUpperCase();

        // Parse structured fields
        if (upperLine.startsWith("RECIPE NAME:")) {
          recipe.name = line.substring(12).trim();
        } else if (upperLine.startsWith("DESCRIPTION:")) {
          recipe.description = line.substring(12).trim();
        } else if (upperLine.startsWith("PREP TIME:")) {
          const match = line.match(/(\d+)/);
          recipe.prepTime = match ? parseInt(match[1]) : 30;
        } else if (upperLine.startsWith("COOK TIME:")) {
          const match = line.match(/(\d+)/);
          recipe.cookTime = match ? parseInt(match[1]) : 30;
        } else if (upperLine.startsWith("SERVINGS:")) {
          const match = line.match(/(\d+)/);
          recipe.servings = match ? parseInt(match[1]) : 4;
        } else if (upperLine.startsWith("DIFFICULTY:")) {
          const difficulty = line.substring(11).trim();
          recipe.difficulty = ["Easy", "Medium", "Hard"].includes(difficulty) ? difficulty : "Medium";
        } else if (upperLine.startsWith("CUISINE:")) {
          recipe.cuisine = line.substring(8).trim();
        } else if (upperLine.startsWith("CATEGORY:")) {
          recipe.category = line.substring(9).trim();
        } else if (upperLine === "INGREDIENTS:") {
          currentSection = "ingredients";
        } else if (upperLine === "INSTRUCTIONS:") {
          currentSection = "instructions";
        } else if (line.startsWith("-") && currentSection === "ingredients") {
          ingredientsList.push(line.substring(1).trim());
        } else if (/^\d+\./.test(line) && currentSection === "instructions") {
          instructionsList.push(line.replace(/^\d+\.\s*/, "").trim());
        }
      }

      // Set defaults and validate
      recipe.name = recipe.name || this.generateDefaultName(request.ingredients);
      recipe.description = recipe.description || `A delicious recipe featuring ${request.ingredients.join(", ")}.`;
      recipe.prepTime = recipe.prepTime || 20;
      recipe.cookTime = recipe.cookTime || 30;
      recipe.servings = recipe.servings || 4;
      recipe.difficulty = recipe.difficulty || "Medium";
      recipe.cuisine = recipe.cuisine || (request.context?.useFilipinoBias !== false ? "Filipino" : "International");
      recipe.category = recipe.category || request.preferences?.category || "Main Course";
      recipe.ingredients = ingredientsList.length > 0 ? ingredientsList : this.generateDefaultIngredients(request.ingredients);
      recipe.instructions = instructionsList.length > 0 ? instructionsList : this.generateDefaultInstructions(request.ingredients);

      // Generate tags
      recipe.tags = this.generateTags(recipe, request);

      // Validate required fields
      if (!recipe.name || !recipe.ingredients.length || !recipe.instructions.length) {
        return null;
      }

      return recipe;
    } catch (error) {
      console.error("Error parsing AI response:", error);
      return null;
    }
  }

  private generateDefaultName(ingredients: string[]): string {
    const primary = ingredients[0] || "Mixed";
    return `${primary.charAt(0).toUpperCase() + primary.slice(1)} Delight`;
  }

  private generateDefaultIngredients(userIngredients: string[]): string[] {
    return userIngredients.map((ing) => `1 cup ${ing}`);
  }

  private generateDefaultInstructions(ingredients: string[]): string[] {
    return [
      `Prepare all ingredients: ${ingredients.join(", ")}.`,
      "Heat oil in a large pan over medium heat.",
      "Add ingredients according to cooking time requirements.",
      "Cook until tender and well combined.",
      "Season with salt and pepper to taste.",
      "Serve hot and enjoy!",
    ];
  }

  private generateTags(recipe: any, request: AIRecipeRequest): string[] {
    const tags = ["ai-generated"];

    if (request.context?.useFilipinoBias !== false) {
      tags.push("filipino-inspired");
    }

    if (recipe.difficulty === "Easy") {
      tags.push("quick", "beginner-friendly");
    }

    if (recipe.prepTime <= 15) {
      tags.push("quick-prep");
    }

    if (recipe.cookTime <= 30) {
      tags.push("quick-cook");
    }

    return tags;
  }

  /**
   * Check if the service is properly configured
   */
  isConfigured(): boolean {
    return this.isEnabled;
  }

  /**
   * Validate ingredients using AI to determine if they are edible and safe
   */
  async validateIngredients(prompt: string): Promise<{ success: boolean; result?: any; error?: string }> {
    if (!this.isEnabled) {
      return {
        success: false,
        error: "Hugging Face API key not configured",
      };
    }

    try {
      const hfRequest: HuggingFaceRequest = {
        inputs: prompt,
        parameters: {
          max_new_tokens: 200,
          temperature: 0.1, // Low temperature for consistent validation
          top_p: 0.9,
          do_sample: true,
          return_full_text: false,
        },
        options: {
          wait_for_model: true,
          use_cache: false,
        },
      };

      const response = await this.client.makeRequest<HuggingFaceResponse[]>(HUGGINGFACE_MODEL, {
        method: "POST",
        body: hfRequest,
      });

      if (!response.success || !response.data) {
        return {
          success: false,
          error: response.error || "Failed to get AI validation response",
        };
      }

      const aiResponse = response.data[0];
      if (!aiResponse?.generated_text) {
        return {
          success: false,
          error: "No validation response from AI",
        };
      }

      // Parse the AI validation response
      const validationResult = this.parseValidationResponse(aiResponse.generated_text);

      return {
        success: true,
        result: validationResult,
      };
    } catch (error: any) {
      console.error("Ingredient validation error:", error);
      return {
        success: false,
        error: error.message || "AI validation service unavailable",
      };
    }
  }

  /**
   * Parse AI validation response into structured data
   */
  private parseValidationResponse(aiText: string): { allEdible: boolean; inedibleIngredients: string[]; reason?: string } {
    try {
      const lines = aiText
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);

      let result = "SAFE";
      let edibleIngredients: string[] = [];
      let inedibleIngredients: string[] = [];
      let reason = "";

      for (const line of lines) {
        const upperLine = line.toUpperCase();

        if (upperLine.startsWith("RESULT:")) {
          result = line.substring(7).trim().toUpperCase();
        } else if (upperLine.startsWith("EDIBLE_INGREDIENTS:")) {
          const ingredientsText = line.substring(19).trim();
          edibleIngredients = ingredientsText
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean);
        } else if (upperLine.startsWith("INEDIBLE_INGREDIENTS:")) {
          const ingredientsText = line.substring(21).trim();
          inedibleIngredients = ingredientsText
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean);
        } else if (upperLine.startsWith("REASON:")) {
          reason = line.substring(7).trim();
        }
      }

      const allEdible = result === "SAFE" && inedibleIngredients.length === 0;

      return {
        allEdible,
        inedibleIngredients,
        reason,
      };
    } catch (error) {
      console.error("Error parsing validation response:", error);
      // Fail-safe: assume ingredients are edible if parsing fails
      return {
        allEdible: true,
        inedibleIngredients: [],
        reason: "Could not parse validation response",
      };
    }
  }

  /**
   * Test the API connection
   */
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    if (!this.isEnabled) {
      return { success: false, error: "API key not configured" };
    }

    try {
      const response = await this.client.makeRequest("gpt2", {
        method: "POST",
        body: {
          inputs: "Test connection",
          parameters: { max_new_tokens: 10 },
        },
      });

      return { success: response.success, error: response.error };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }
}

// Singleton instance
export const huggingFaceService = new HuggingFaceService();
