// OpenAI API service for AI recipe generation using official SDK
import OpenAI from "openai";
import { OPENAI_CONFIG } from "../config/apiConfig";
import { AIRecipeRequest, AIRecipeResponse } from "../types/api";

export class OpenAIService {
  private client: OpenAI | null;
  private isEnabled: boolean;

  constructor() {
    // Check API key availability at runtime, not just module load time
    const apiKey = process.env.EXPO_PUBLIC_OPENAI_API_KEY || OPENAI_CONFIG.apiKey;
    this.isEnabled = !!apiKey;

    // Initialize OpenAI client with official SDK
    if (this.isEnabled) {
      this.client = new OpenAI({
        apiKey: apiKey,
        timeout: OPENAI_CONFIG.timeout,
        maxRetries: OPENAI_CONFIG.retryAttempts,
      });
    } else {
      this.client = null;
    }
  }

  /**
   * Generate a recipe using OpenAI ChatGPT models
   */
  async generateRecipe(request: AIRecipeRequest): Promise<AIRecipeResponse> {
    if (!this.isEnabled || !this.client) {
      return {
        success: false,
        error: "OpenAI API key not configured",
        fallbackUsed: false,
      };
    }

    try {
      const prompt = this.buildRecipePrompt(request);
      const startTime = Date.now();

      // Try different models in order of preference
      const modelsToTry = [
        OPENAI_CONFIG.defaultModel, // gpt-4o-mini
        "gpt-3.5-turbo", // fallback
        "gpt-4o", // premium fallback
      ];

      let response;
      let usedModel = OPENAI_CONFIG.defaultModel;

      for (const model of modelsToTry) {
        try {
          console.log(`🤖 Trying model: ${model}`);
          response = await this.client.chat.completions.create({
            model: model,
            messages: [
              {
                role: "system",
                content:
                  "You are a professional chef and recipe developer. Create detailed, practical, and delicious recipes. Always respond with properly formatted recipes that include all required sections.",
              },
              {
                role: "user",
                content: prompt,
              },
            ],
            temperature: OPENAI_CONFIG.modelSettings[model as keyof typeof OPENAI_CONFIG.modelSettings]?.temperature || 0.7,
            max_tokens: OPENAI_CONFIG.modelSettings[model as keyof typeof OPENAI_CONFIG.modelSettings]?.maxTokens || 1500,
            top_p: OPENAI_CONFIG.modelSettings[model as keyof typeof OPENAI_CONFIG.modelSettings]?.topP || 0.9,
          });
          usedModel = model;
          console.log(`✅ Successfully used model: ${model}`);
          break;
        } catch (error: any) {
          console.log(`❌ Model ${model} failed: ${error.message}`);
          if (model === modelsToTry[modelsToTry.length - 1]) {
            // Last model failed, re-throw the error
            throw error;
          }
          // Continue to next model
        }
      }

      const processingTime = Date.now() - startTime;

      if (!response) {
        return {
          success: false,
          error: "No response received from any available model",
          fallbackUsed: false,
        };
      }

      const aiResponse = response.choices[0];

      if (!aiResponse?.message?.content) {
        return {
          success: false,
          error: "No recipe generated by AI",
          fallbackUsed: false,
        };
      }

      // Parse the AI response into a structured recipe
      const parsedRecipe = this.parseAIResponse(aiResponse.message.content, request);

      if (!parsedRecipe) {
        console.log("❌ AI parsing failed");
        return {
          success: false,
          error: "Failed to parse AI response into recipe format",
          fallbackUsed: false,
        };
      }

      return {
        success: true,
        recipe: parsedRecipe,
        apiMetadata: {
          model: usedModel,
          processingTime,
          tokensUsed: response.usage?.total_tokens || 0,
        },
      };
    } catch (error: any) {
      console.error("OpenAI API error:", error);
      return {
        success: false,
        error: `OpenAI service error: ${error.message}`,
        fallbackUsed: false,
      };
    }
  }

  /**
   * Build an optimized prompt for recipe generation
   */
  private buildRecipePrompt(request: AIRecipeRequest): string {
    const { ingredients, preferences, context, searchQuery } = request;
    const filipinoBias = context?.useFilipinoBias !== false; // Default to true

    // If this is a search query, use the search prompt
    if (searchQuery) {
      return searchQuery;
    }

    let prompt = "Create a recipe with the following format:\n\n";
    prompt += "RECIPE NAME: [Recipe name - can be traditional Filipino dish or creative new name]\n";
    prompt += "DESCRIPTION: [Brief description of the dish]\n";
    prompt += "PREP TIME: [minutes]\n";
    prompt += "COOK TIME: [minutes]\n";
    prompt += "SERVINGS: [number]\n";
    prompt += "DIFFICULTY: [Easy/Medium/Hard]\n";
    prompt += "CUISINE: [cuisine type]\n";
    prompt += "CATEGORY: [Breakfast/Main Course/etc.]\n";
    prompt += "INGREDIENTS:\n";
    prompt += "- [ingredient with quantity]\n";
    prompt += "INSTRUCTIONS:\n";
    prompt += "1. [step by step instructions]\n\n";

    prompt += `Create a recipe using these ingredients as the main components: ${ingredients.join(", ")}.\n`;
    prompt +=
      "You can either: (1) Create a traditional Filipino recipe that uses these ingredients (like adobo, sinigang, tinola, etc.), or (2) Invent a completely new and original dish with a creative name. ";
    prompt += "If creating a traditional dish, ensure it follows authentic Filipino cooking methods and seasonings. ";
    prompt += "If inventing a new dish, give it a creative name that describes the ingredients and cooking method.\n";

    if (filipinoBias) {
      prompt += "Use Filipino cooking techniques and flavor profiles when possible. ";
      prompt += "You may add common Filipino seasonings like soy sauce, vinegar, garlic, onions, ginger to complement the main ingredients. ";
    }

    if (preferences?.cuisine && preferences.cuisine !== "Filipino") {
      prompt += `Cuisine style: ${preferences.cuisine}. `;
      prompt += "Adapt the cooking techniques and seasonings to match this cuisine style. ";
    }

    if (preferences?.category) {
      prompt += `Category: ${preferences.category}. `;
    }

    if (preferences?.difficulty) {
      prompt += `Difficulty level: ${preferences.difficulty}. `;
    }

    if (preferences?.maxPrepTime) {
      prompt += `Maximum prep time: ${preferences.maxPrepTime} minutes. `;
    }

    if (preferences?.servings) {
      prompt += `Serves: ${preferences.servings} people. `;
    }

    if (preferences?.dietary?.length) {
      prompt += `Dietary requirements: ${preferences.dietary.join(", ")}. `;
    }

    prompt += "\nEnsure the recipe is practical, delicious, and the name clearly describes what the dish is.";

    return prompt;
  }

  /**
   * Parse AI response text into structured recipe data
   */
  private parseAIResponse(aiText: string, request: AIRecipeRequest): AIRecipeResponse["recipe"] | null {
    try {
      const lines = aiText
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);
      const recipe: any = {
        tags: [],
        confidence: 0.9, // Higher confidence for OpenAI
        source: "ai" as const,
      };

      let currentSection = "";
      let ingredientsList: string[] = [];
      let instructionsList: string[] = [];

      for (const line of lines) {
        const upperLine = line.toUpperCase();

        // Parse structured fields
        if (upperLine.startsWith("RECIPE NAME:")) {
          recipe.name = line.substring(12).trim();
        } else if (upperLine.startsWith("DESCRIPTION:")) {
          recipe.description = line.substring(12).trim();
        } else if (upperLine.startsWith("PREP TIME:")) {
          const match = line.match(/(\d+)/);
          recipe.prepTime = match ? parseInt(match[1]) : 30;
        } else if (upperLine.startsWith("COOK TIME:")) {
          const match = line.match(/(\d+)/);
          recipe.cookTime = match ? parseInt(match[1]) : 30;
        } else if (upperLine.startsWith("SERVINGS:")) {
          const match = line.match(/(\d+)/);
          recipe.servings = match ? parseInt(match[1]) : 4;
        } else if (upperLine.startsWith("DIFFICULTY:")) {
          const difficulty = line.substring(11).trim();
          recipe.difficulty = ["Easy", "Medium", "Hard"].includes(difficulty) ? difficulty : "Medium";
        } else if (upperLine.startsWith("CUISINE:")) {
          recipe.cuisine = line.substring(8).trim();
        } else if (upperLine.startsWith("CATEGORY:")) {
          recipe.category = line.substring(9).trim();
        } else if (upperLine === "INGREDIENTS:") {
          currentSection = "ingredients";
        } else if (upperLine === "INSTRUCTIONS:") {
          currentSection = "instructions";
        } else if (line.startsWith("-") && currentSection === "ingredients") {
          ingredientsList.push(line.substring(1).trim());
        } else if (/^\d+\./.test(line) && currentSection === "instructions") {
          instructionsList.push(line.replace(/^\d+\.\s*/, "").trim());
        }
      }

      // Set defaults and validate
      recipe.name = recipe.name || this.generateDefaultName(request.ingredients);
      recipe.description = recipe.description || `A delicious recipe featuring ${request.ingredients.join(", ")}.`;
      recipe.prepTime = recipe.prepTime || 20;
      recipe.cookTime = recipe.cookTime || 30;
      recipe.servings = recipe.servings || 4;
      recipe.difficulty = recipe.difficulty || "Medium";
      recipe.cuisine = recipe.cuisine || (request.context?.useFilipinoBias !== false ? "Filipino" : "International");
      recipe.category = recipe.category || request.preferences?.category || "Main Course";
      recipe.ingredients = ingredientsList.length > 0 ? ingredientsList : this.generateDefaultIngredients(request.ingredients);
      recipe.instructions = instructionsList.length > 0 ? instructionsList : this.generateDefaultInstructions(request.ingredients);

      // Generate tags
      recipe.tags = this.generateTags(recipe, request);

      // Validate required fields
      if (!recipe.name || !recipe.ingredients.length || !recipe.instructions.length) {
        return null;
      }

      return recipe;
    } catch (error) {
      console.error("Error parsing AI response:", error);
      return null;
    }
  }

  private generateDefaultName(ingredients: string[]): string {
    const primary = ingredients[0] || "Mixed";
    return `${primary.charAt(0).toUpperCase() + primary.slice(1)} Delight`;
  }

  private generateDefaultIngredients(userIngredients: string[]): string[] {
    return userIngredients.map((ing) => `1 cup ${ing}`);
  }

  private generateDefaultInstructions(ingredients: string[]): string[] {
    return [
      `Prepare all ingredients: ${ingredients.join(", ")}.`,
      "Heat oil in a large pan over medium heat.",
      "Add ingredients according to cooking time requirements.",
      "Cook until tender and well combined.",
      "Season with salt and pepper to taste.",
      "Serve hot and enjoy!",
    ];
  }

  private generateTags(recipe: any, request: AIRecipeRequest): string[] {
    const tags = ["ai-generated", "openai"];

    if (request.context?.useFilipinoBias !== false) {
      tags.push("filipino-inspired");
    }

    if (recipe.difficulty === "Easy") {
      tags.push("quick", "beginner-friendly");
    }

    if (recipe.prepTime <= 15) {
      tags.push("quick-prep");
    }

    if (recipe.cookTime <= 30) {
      tags.push("quick-cook");
    }

    return tags;
  }

  /**
   * Generate a fallback recipe when AI services are unavailable
   */
  private generateFallbackRecipe(request: AIRecipeRequest): AIRecipeResponse["recipe"] {
    const { ingredients, preferences } = request;

    // Create a simple but practical recipe based on ingredients
    const recipeName = this.generateFallbackRecipeName(ingredients, preferences?.cuisine);
    const isFilipino = !preferences?.cuisine || preferences?.cuisine === "Filipino";

    return {
      name: recipeName,
      description: `A delicious ${isFilipino ? "Filipino-style" : ""} dish featuring ${ingredients.slice(0, 3).join(", ")}${ingredients.length > 3 ? " and more" : ""}.`,
      prepTime: preferences?.maxPrepTime || 20,
      cookTime: 25,
      servings: preferences?.servings || 4,
      difficulty: (preferences?.difficulty as "Easy" | "Medium" | "Hard") || "Medium",
      cuisine: preferences?.cuisine || "Filipino",
      category: preferences?.category || "Main Course",
      ingredients: this.generateFallbackIngredients(ingredients, isFilipino),
      instructions: this.generateFallbackInstructions(ingredients, isFilipino),
      tags: this.generateFallbackTags(preferences, isFilipino),
      confidence: 0.6, // Lower confidence for fallback
      source: "local" as const,
    };
  }

  private generateFallbackRecipeName(ingredients: string[], cuisine?: string): string {
    const primary = ingredients[0]?.toLowerCase() || "mixed";
    const isFilipino = !cuisine || cuisine === "Filipino";

    if (isFilipino) {
      // Generate Filipino-style names
      if (ingredients.some((ing) => ing.toLowerCase().includes("chicken"))) {
        return "Chicken Adobo Delight";
      }
      if (ingredients.some((ing) => ing.toLowerCase().includes("pork"))) {
        return "Pork Guisado Supreme";
      }
      if (ingredients.some((ing) => ing.toLowerCase().includes("fish"))) {
        return "Fish Sinigang Fusion";
      }
      if (ingredients.some((ing) => ing.toLowerCase().includes("egg"))) {
        return "Torta Style Scramble";
      }
      return `${primary.charAt(0).toUpperCase() + primary.slice(1)} Kapampangan Style`;
    }

    return `${primary.charAt(0).toUpperCase() + primary.slice(1)} Fusion Delight`;
  }

  private generateFallbackIngredients(userIngredients: string[], isFilipino: boolean): string[] {
    const baseIngredients = userIngredients.map((ing) => `1 cup ${ing}`);

    if (isFilipino) {
      return [...baseIngredients, "2 cloves garlic, minced", "1 medium onion, sliced", "2 tbsp soy sauce", "1 tbsp vinegar", "1 tsp black pepper", "2 tbsp cooking oil", "Salt to taste"];
    }

    return [...baseIngredients, "2 cloves garlic, minced", "1 medium onion, diced", "2 tbsp olive oil", "Salt and pepper to taste"];
  }

  private generateFallbackInstructions(ingredients: string[], isFilipino: boolean): string[] {
    if (isFilipino) {
      return [
        "Heat oil in a large pan over medium heat.",
        "Sauté garlic and onions until fragrant and golden.",
        `Add the main ingredients: ${ingredients.slice(0, 2).join(" and ")}.`,
        "Pour in soy sauce and vinegar. Let it simmer without stirring for 3 minutes.",
        "Add black pepper and mix gently.",
        "Cover and simmer for 15-20 minutes until tender.",
        "Season with salt to taste.",
        "Serve hot with steamed rice. Enjoy your Filipino feast!",
      ];
    }

    return [
      "Heat olive oil in a large skillet over medium heat.",
      "Add garlic and onions, cook until softened.",
      `Add ${ingredients.join(", ")} and cook until properly heated through.`,
      "Season with salt and pepper to taste.",
      "Cook for 10-15 minutes, stirring occasionally.",
      "Serve hot and enjoy!",
    ];
  }

  private generateFallbackTags(preferences: any, isFilipino: boolean): string[] {
    const tags = ["local-fallback", "quick-recipe"];

    if (isFilipino) {
      tags.push("filipino", "comfort-food");
    }

    if (preferences?.difficulty === "Easy") {
      tags.push("beginner-friendly");
    }

    return tags;
  }

  /**
   * Check if the service is properly configured
   */
  isConfigured(): boolean {
    // Check at runtime to ensure we have the latest environment variable
    const apiKey = process.env.EXPO_PUBLIC_OPENAI_API_KEY || OPENAI_CONFIG.apiKey;
    const isConfigured = !!apiKey;

    // Debug logs removed - service is working correctly

    return isConfigured;
  }

  /**
   * Validate ingredients using AI to determine if they are edible and safe
   */
  async validateIngredients(prompt: string): Promise<{ success: boolean; result?: any; error?: string }> {
    if (!this.isEnabled || !this.client) {
      return {
        success: false,
        error: "OpenAI API key not configured",
      };
    }

    try {
      // Try different models for validation
      const modelsToTry = [
        OPENAI_CONFIG.defaultModel, // gpt-4o-mini
        "gpt-3.5-turbo", // fallback
        "gpt-4o", // premium fallback
      ];

      let response;
      for (const model of modelsToTry) {
        try {
          response = await this.client.chat.completions.create({
            model: model,
            messages: [
              {
                role: "system",
                content: "You are a food safety expert. Analyze ingredients and determine if they are safe and edible for cooking. Respond with structured data.",
              },
              {
                role: "user",
                content: prompt,
              },
            ],
            temperature: 0.1, // Low temperature for consistent validation
            max_tokens: 300,
            top_p: 0.9,
          });
          break; // Success, exit the loop
        } catch (error: any) {
          if (model === modelsToTry[modelsToTry.length - 1]) {
            throw error; // Last model failed, re-throw
          }
          // Continue to next model
        }
      }

      if (!response) {
        return {
          success: false,
          error: "No response received from any available model",
        };
      }

      const aiResponse = response.choices[0];
      if (!aiResponse?.message?.content) {
        return {
          success: false,
          error: "No validation response from AI",
        };
      }

      // Parse the AI validation response
      const validationResult = this.parseValidationResponse(aiResponse.message.content);

      return {
        success: true,
        result: validationResult,
      };
    } catch (error: any) {
      console.error("Ingredient validation error:", error);
      return {
        success: false,
        error: error.message || "AI validation service unavailable",
      };
    }
  }

  /**
   * Parse AI validation response into structured data
   */
  private parseValidationResponse(aiText: string): { allEdible: boolean; inedibleIngredients: string[]; reason?: string } {
    try {
      const lines = aiText
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);

      let result = "SAFE";
      let inedibleIngredients: string[] = [];
      let reason = "";

      for (const line of lines) {
        const upperLine = line.toUpperCase();

        if (upperLine.startsWith("RESULT:")) {
          result = line.substring(7).trim().toUpperCase();
        } else if (upperLine.startsWith("INEDIBLE_INGREDIENTS:")) {
          const ingredientsText = line.substring(21).trim();
          inedibleIngredients = ingredientsText
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean);
        } else if (upperLine.startsWith("REASON:")) {
          reason = line.substring(7).trim();
        }
      }

      const allEdible = result === "SAFE" && inedibleIngredients.length === 0;

      return {
        allEdible,
        inedibleIngredients,
        reason,
      };
    } catch (error) {
      console.error("Error parsing validation response:", error);
      // Fail-safe: assume ingredients are edible if parsing fails
      return {
        allEdible: true,
        inedibleIngredients: [],
        reason: "Could not parse validation response",
      };
    }
  }

  /**
   * Test the API connection
   */
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    if (!this.isEnabled || !this.client) {
      return { success: false, error: "API key not configured" };
    }

    try {
      await this.client.chat.completions.create({
        model: OPENAI_CONFIG.defaultModel,
        messages: [{ role: "user", content: "Test connection" }],
        max_tokens: 10,
      });

      return { success: true, error: undefined };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }
}

// Singleton instance
export const openaiService = new OpenAIService();
